

Next.js Route Handlers, Headers, Middleware, Rendering, and RSC – Complete Guide

1. Headers in Route Handlers

HTTP headers are metadata associated with API requests and responses.

1.1 Request Headers (Client → Server)

Sent by the client (browser) to the server. They help the server understand and process the request.

| Header        | Description                         | Example                                               |
| ------------- | ----------------------------------- | ----------------------------------------------------- |
| User-Agent    | Browser & OS information            | User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) |
| Accept        | Types of content client can process | Accept: text/html, application/json                   |
| Authorization | Client authentication               | Authorization: Bearer <token>                         |

Example in Next.js route handler:

```javascript
export async function GET(request) {
  const userAgent = request.headers.get("user-agent");
  return new Response(`Your browser is ${userAgent}`);
}
```

1.2 Response Headers (Server → Client)

Sent by the server to the client to describe server info or response content.

| Header       | Description                 | Example                                        |
| ------------ | --------------------------- | ---------------------------------------------- |
| Content-Type | Type of response data       | Content-Type: application/json                 |
| Set-Cookie   | Sends cookies to the client | Set-Cookie: sessionId=abc123; HttpOnly; Secure |

2. Cookies in Route Handlers

Cookies are small pieces of data sent by the server to the browser. Browsers store them and send them back on future requests.

Uses:

1. Session management (logins, shopping carts)
2. Personalization (themes, preferences)
3. Tracking (analytics, user behavior)

Example:

```javascript
export async function GET(request) {
  return new Response("Hello", {
    headers: { "Set-Cookie": "theme=dark; Path=/; HttpOnly" }
  });
}
```

3. Caching in Route Handlers

* GET requests are cached by default.
* To disable caching:

  * Use dynamic mode in segment config
  * Use headers() or cookies()
  * Use any method other than GET

4. Middleware in Next.js

Middleware intercepts requests/responses before reaching the route.

Uses:

* Redirecting users
* URL rewriting
* Authentication checks
* Header/cookie management

Conditional activation:

* Custom matcher config
* Conditional statements

Example:

```javascript
export function middleware(req) {
  if (!req.cookies.get("auth")) {
    return NextResponse.redirect("/login");
  }
}
```

5. Rendering in React & Next.js

Rendering = turning code into user interfaces.

5.1 Client-Side Rendering (CSR)

* Happens entirely in the browser
* Standard for SPAs

Drawbacks:

* SEO: HTML mostly <div> → poor indexing
* Performance: Browser fetches data, computes UI → blank screen or spinner initially
* JS bundle: Larger apps = slower initial load

5.2 Server-Side Rendering (SSR)

* HTML generated per request on server
* Benefits: SEO-friendly, fast first paint

Hydration: React attaches JS, state, and events to HTML in the browser.

SSR Drawbacks (“All-or-Nothing” waterfall):

1. Data fetching must finish before server can render
2. JS must fully load before hydration
3. All components must hydrate before interaction

Example:

```javascript
export async function getServerSideProps() {
  const posts = await fetchPosts();
  return { props: { posts } };
}
```

5.3 Static Site Generation (SSG)

* HTML generated at build time
* Cached via CDN → fast
* Ideal for content that rarely changes

Example:

```javascript
export async function getStaticProps() {
  const posts = await fetchPosts();
  return { props: { posts } };
}
```

Prefetching: Next.js automatically preloads routes visible in the viewport for fast navigation.

5.4 Streaming & Selective Hydration

* Streaming: HTML sent in chunks → user sees parts progressively
* Selective Hydration: Only sections needing interactivity hydrate first
* React Suspense enables this

Benefits:

* Faster interactivity
* Heavy JS doesn’t block page

6. React Server Components (RSC)

RSC splits components into Server Components (server-only) and Client Components (browser).

| Component        | Runs Where  | Purpose                                                                         |
| ---------------- | ----------- | ------------------------------------------------------------------------------- |
| Server Component | Server only | Fetch data, access DB/API, generate HTML, protect secrets, reduce client bundle |
| Client Component | Browser     | Interactivity, events, state, hooks, browser APIs                               |

Example (Server Component):

```javascript
export default async function Posts() {
  const posts = await fetchPosts();
  return <div>{posts.map(p => <p key={p.id}>{p.title}</p>)}</div>;
}
```

6.1 Server-only Code

* Only executed on server
* Must not be bundled into client JS
* Server-only packages throw build-time errors if imported incorrectly

6.2 Client-only Code

* Interacts with DOM, window, localStorage
* Use client-only packages to prevent server execution

6.3 Context Providers in RSC

* Context cannot be created in server components
* Place providers inside Client Components

6.4 Client Component Placement

* Place low in component tree
* Server components: fetch/render data
* Client components: handle interactivity

7. Rendering Workflow (Text Diagram)

```
User requests page
        │
   ┌────┴─────┐
   │          │
  SSG        SSR
(Build time) (Request time)
   │          │
HTML + RSC Payload sent to browser
        │
      Hydration (React attaches events & state)
        │
   ┌────┴─────┐
   │ Fully Interactive UI │
   └───────────┘
        │
       CSR (Browser renders all)
```

Server & Client Component Pattern

```
Server Components
- Fetch data
- Access backend
- Generate HTML
- Keep secrets server-side
        │
        ▼
HTML + RSC Payload
        │
Client Components
- Interactivity
- State & Hooks
- Browser APIs
        ▼
Fully Interactive UI
```

Rendering Strategies Summary

| Strategy | HTML Generated     | Pros                           | Cons                               | Use Case           |
| -------- | ------------------ | ------------------------------ | ---------------------------------- | ------------------ |
| CSR      | Browser            | Fast interactions              | Poor SEO, slow first paint         | SPAs               |
| SSR      | Server per request | SEO friendly, fast first paint | Data fetching & hydration required | Dashboards         |
| SSG      | Build time         | Fast, cacheable                | Not dynamic                        | Blogs, Docs        |
| RSC      | Server + Client    | Smaller bundle, streaming      | Must split server/client logic     | Next.js App Router |

Key Takeaways

1. SSG: Pre-build pages → fast
2. SSR: Personalized pages per request
3. CSR: Browser renders everything → SPAs
4. RSC: Server + client split → faster + interactive
5. Middleware: Handles headers, cookies, redirection, authentication
6. Hydration: React attaches interactivity
7. Streaming + selective hydration: Progressive UI, faster interactivity
8. Server-only & client-only code: Keep separate for speed & security

