correct the spelling and explain with example Headers in Route Handlers :
Http headers represent the metadata associated with the api request and respond 
Reusest Header:
              These are sent by the Client ,Such as Web Browser , to the Server  .They Contain Essential INformation information about the request Which Helps the Server UNderstand and process it correctly 

User Agent which defines about the browsrr and Opersting System to the server 
Accept: Which indicate the content types like test video or image formate that the client can't pprooces 
Authorization:header used by the client to authenticate itself to the server 

REsponse Header 
                these are sent back from the server to the client >They provide the information about the server and the data being senty in the response 

Content -TYpe :
                 header which indicate the meta type of the respoinse .It tells the ciient what the data type of the return content is ,such as text/Html  for HTML  documents ,application/json for thr JSON data ect. 

Cookies in route Handlers :
Cookies are small piece of data tthat server sends to a users web browser 
the browse may store  the cookie an send it back to same servwer with later reqiest 
cookies are mainly used for three purpose 
-Session management like logins and shopping carts 
-personalization like user perferences and themes
-tracking like recording and analysing user behaviour 
 

Caching the ROute Handler 


route handler are cached by defalt whwn using the get method with Response object in the NExt.js 
 HOw to opt out of cachiinng 
 -dynamic mode in segment config option 
 -using the Request object with the Get method 
 -employing dynamic function like Heders() and cookies()
 -using any other method than Get()


MIddleware :
             in nest js the middleware is a powerful feture that offers a  robust way to intercept and  controol flow of the request and response within your application 
 it does thiis at a global level siginficantly enhancing the feature like rediraction ,url rewritr ,authentication ,headereand cookies management and more  
 Middleware allows us to specify paths where it will be active
 -custoume matcher config 
 -conditional statement 

 efficitevly control and interceot the requst nad response cycle  enabling the urll rewrite rewrites and the manipulation of header and cookies


 Rendering 

 redering is the process that transform the code youn write into user interfaces 
 in next.js ,choosing the right  time  and pplace to do the rendering is cital for building a  performant application 
 css ,ssr and rscs

 rendering in react ->rendering in the Next.js

 rendering in the React 

 csr :
 this method of rendering ,where the componenyt code is transformed into the interface directly within the browser (the client) is also known as client -side rendering

 csr quickly became the standard for SPAs ,with widesoppace 
 it was no loner before developer begain noticing some inheriwnt drawabacks to this approach 

 drawbacks :
 seo:generating HTMl that mainly contains a single div tag is noyt optimal for SEO as it provides  little content for search engines to index 
 performance :Having the browser handle all the work ,such as  fetchingb data computing the ui and making HTML interacton can sloe down the things .users migh see a blank screen or a loding apinner ehile the ppage loads 

 each new feature added to the application increase the sixze oof the js bundle prologing the time for the suer to see the ui 


 ssr
  -it significantly improves the seo because search engine can easily index the the server rndering content 
  -users can immidiately see the page htmll content ,instead of blank screen or loading spinner 

  Hydration 
  dueing hydration ,react take control  in the browser ,reconstructing the components tree based in the memory based on the sttatic html that was served 
  it carefullly plans ther placememt of intensive element withiin the tree .then react proceed to bind the necessary javascrippt  logic to these elements 
  this involve initilization the aopplication state ,atttaching event handlers for ther acction such sa clicjk and mouesoveer and setting up other synamic functionalities require for fully interactive use experience 
  -Swevwe Side Solitiion 
  1. Static Sitte Generation (SSG)
  2. Swrver Side Rendering (SSR)

SSG occure at build time When the application is deployd on the server >This results in page that is are alreday rendered and ready to serve .It is ideal for comntent thet doesn't chhange often ,like blog post

SSsr ,on the other hand , render the pages on-demand in response to the use request.Itbis suitablle for the personalized content like socila mesis feeda ,hwere the html depend on  the loggged -in user
SSr was sifnificantlly improved over client side  rendering  providing faster initila page load and better SEO 
  
Drawbacks of the SSR 
1. younhave to fetch every thing befoore you can show anythinfg 

Components connot start rebdering and then pause or ewait whilw dat is still behing loaded 

if a component needs to fetch the data froom the databsee or another source like API thiis fetch be completed befoore the server can bgain rendering the page 

This can delay the server response timme to the browser,as the server must finsish collecting necessary dat before any part of the page can be sent to then client 

2. TOu have toload everything befopre you can hydrate anything 
For Sucessfull Hhydration ,where React adds inteactivity to the server --rendering HTMLL the componentyb tree inthe browser must exactly mnatch the  Server-generated components tree 
THis means tThst all the js for the component must be loades on the client beefore you cann start Hydrating any of them
3. YOu have to hydrate everything before you can interac with anything 
React hydrates the component ther componenet tree in a single pass ,meaning once sttart Hydratu=ing it wont stop until it iis finished withn the entire tree 
As a consequence All componesnts must be hydrate  before you can interact withn any of them 
 
All or nothing 
1.hevingg to laod the page entierly 
2. load the js for the entire page and 
2. hydrate the entire page 
 Ccreate an "all of=r nothing" waterfall problrm that spans from the server to the client ,Where each issue  must be restord before moving the next one
 This  is inefficient if some parts of your appp are slower that other, as is often the case in real-life apps

 Suspense SSr architecture
 use the <suspense> components to unlock the major ssr ffeature 
 1. Html streaming on the server 
 2. selective HYdration on the client 
  Html streaming on the server 
  you  don have to fetch everything before you can show anything 
  if a particular section delays  the imnitial Html <it can be seamselly integrate  into the stream later
  This is the essence of how suspense facilates server side HTMl streaming

THe Other Challanges  
until the js from the main section is loaded ,client-side appp hydrtion cant  sttsrt 
And if the js filebundle foer the main section is large ,this could significantly delay this processs

IN the response of this We can use the COde SPlitting 
Cod Splliting allows you to mark specific code segment as not immediately necessary for loading ,signaliing your bundler to segregate them intgo seperate <script > tag
Using "React Lazy " for the code splitting enable you to seperate the main section code from the js bundle 
THe js containing Rect and the code for the entiore application <excluding the main section <can now be downlaioded indepenently by the client without having to wait for ther main section code 

 Selective Hydration 
   By Wrapping the main section within <Suspense > you 've indicate to react that if=t should not prevent the rest of the page from just streaming but allso from hydration 
    THis feature ,Ccalllde "selective Hydration " allows  for then hydration of the section as they become available ,before the rest of the HTMl and the JS code are fuklly downloaded 
    thanks for the selective hydartion ,a heavy pieace of Js doesnt prevent the lrest oof the page from becomming interactive 

 Selective Hydration on the client side
  Selective hydaratin offers a solution to the third  isse : the necessaty to "hydrate everything to intteract withn anythiing 
  Rect begaiuns hydrating as ahoon as possible  ,enabliungf interaction with elememnts like header and side navigation wiithout waiting for the ain content  to be hydrated 
  Thius peeocess iis managed automatically  by the react 
  In this scenario where the multiple components are awaiting the hydration ,React priotizes hydration base on user interaction 
   Drawbacks of SSR _alll or nothing waterfall
   1. Data fetching must be completed before the server can begin reb=ndering the HTML
   2. THe JS require for  the components need fully loaded on the client side befoire the huydration proocess can start 
   3. All components hhave to hydrate before they become intteractive
    Drawbackof Suspense SSr 
   First ,even though JS code is stremed to the browser asynchronously ,evemntually ,the entire 
code for a web page must be downloaded by the user 
As application add mopre feature ,the  amount of code users need too download also grow .THis leads to an important question 
Should User ereally have to download so much data?

Second, the current apporach require that all Rect component underge hyudration on the client side ,irrespective of their actual need for the interactivity 
THis process can inefficiently spent resources and extend the loading times and  time interactivy for the users ,as teir device need process and  render components that might not even require client side interaction 
THis kleads to another QUestion 
should all components ber hydrated ,even those don't need interactivity 

Third ,in split of service superior capicity for handeling intensive processing task  ,the bulk of JS execute still takes on users device 
This can slower down  the performance <especially on that device that are not very popwerfull 
YHis  lead to another important Question :
should so much  of work be done on the user device 

React Server componentts 
Rect Srver Components  represent request o new architecture design by the React team 
This apporach aims to leverage the strenghts of both server and client  ennvironment ,optimizing for efficiiency ,load times and inteactivity 
THis architecture introduces a dula-component modal 
-client Side 
-Server Side

This dinstinct  is not based on the functiuonality of the  components but rather on where they execute and the  specific environment  they are desighed to interact  with  
Client Components:
                  Client Conponrennts are the  fakiliar  ract compoonrnt we've  using 
                  They are typicallty rnderd on  the client side (CSr)but ,they can also  be rendered to Htmlonnthe server  (SSR) ,allowing user to immidaiatlly see the page HTMl content rsther than black sct=reen 
                   Components that primrly  run on the client but cs\an also once on the server as an optimization stagety 
                    cliet  components hav access to the client environment ,such as the browser  allowing the to use state,effects ,events listners to handlle immidiately and also access browser -exclusive APi's like geolocation orlocalstorage ,allowing  you to build Ui for specific use case 
                     In fact ,the term "cilient COmponent" doesnt siignify anything new it simply hepls differentiate these  components from these  commponents from the newly introosuced server Components 
 Server Components :
                     Seerver Component represent a new type of React component specially  designed to operate exclusively on the server 
                     And unlike the client component, the code stay in the server and never downloaded on the client 
                      THese design choic multiple offers multiple benifit to React application 
  Benifits Of server Components:
  RENDER BUNDLE SIZES 
                     Server Components do not senfd code to the client ,allowing large dependencies to remain server-side 
                     this benifit usrs with slower internt  connection or less capable device by eliminating the  need to downlod ,parse and execute JJS for these components 
                     Additionally ,it removes the hydration steps ,sppeeding up app and interaction 

    direct access  to the  SERVER-SIDE RESOURCES 
                    By hhaving acess to server-side  resources like database or file system ,Server Componentts enable efficientdata fetching and rendering without needing additional client cide-prcocessing 
                    Leveraging the Server's computational power  and prooximity to data soureces ,they manage compute-u=intyensive rendering  tasks and  only intractive pieces of code to the client 

 ENHANCE SECURITY 
                 Server Components exclusive Server side execution enhance security by keeping sensitive data and logic ,including tokens and aApi's keys, away from the client side 
 IMPROVVES DATA DETCHING;
                       sERVER components  enhhance data fetching effiiciency 
                       TYpically  ,when fetching data on the client-side using useEffect ,aclhild component cannot begain loading its data until the parent component has finished loading its own 
                       This seqential fetching of the dtaa ofte leads  to poor performance 
                        The main issue is not the round trips themselve ,but that these rounf trip are made from the client to the server 
                        Server Component enablle application to shift thesr  sequential rounnd trip to the server side 
                        By mob=ving this logic to the server,request latency is reduced,and averall  performance is improved ,eliminating the "server Side " waterfall
CACHING 
        Rendering on the server enable caching of the results,which can be reused in subsequent request and across the different users 
        THis approach can siiginficantly improve perfoprmance and reduce cost by minimizing the amount of rendering and data fetching required for eeach request
FAXTER INITIAL PAGE LOAD AND FIRST CONTENFUL PAINT 
          sIXTH ,initial page load and fiorst contrntful paint are significantly improved with Server Compnent 
          By generating Html on the server ,page bbecome immidiately visiblle to users  without the delay of  dounloading ,parsing  and executing JS 
IMPROVED SEO:
             Rendering Search Engine optimization,the server-rendering HTML is fully accessable to search engine bots ,enhancing the indexability of  your page 
EFFIVIENT STREAMING  
              server Components allows  the rendering process to be divided into managable chunks ,which are then streamed to the client as soon as they are ready 
              THis apporach allows user to start seeing parts of the page earlier ,elimnating the need to wait for the page to finish rendering on the server 
 Rendering the Server Component 
             Server Component take charge of the data fetching and static rendering ,while Client Coponents are tasked eith rendering the interactivve elements of the application 
             The bottom line  is thst the RSC architecture enable React appplication to levverager the beat aspect of both server and client  rendering ,all while using a singl;e langiage ,a  singlle framework ,and cohesiver set of  API's 

                           
KEY TAKEAYAYS OF RSC 
     RSC introducer a new way of vbilfding  react apps by searching components into  two ytpes:Server Component and Client Commponent  
    
    Sserver Coponent  run only on the server ,acccessing data prefetching content without bbeing sent to the  brpwser ,which make the app fast for the users because less INformationneed to ber doownnnlkoaded 
    THis infpormation can'r manage clicks or interacton directlyb 
  
  Client  Component ,on the other hand ,works in the  user's browser and handle alll the interaction part of the appp ,like  clicking and typing  
  They can also be rendered on the server for a fast initial load of the site.This steup heps make website fater ,more secure and easier for everyone to use ,no matyter where hthey are or what device theyre usinng .


  RSC and Next js 
    "This is dive intoo the evolution of rendering in React is greater,vishwah but how exactly it hepls underestand rendering in NExt,js ?Which the connections?
    The  spp routter in NExt.js is built around the rsc Aerchitecuure 
    All the feature and bbeniifits we.have discussed are alkready bake into the lates version of nest,js 

    All the feature and benifit we've siscussed  sre already baked into the latest version of the next.js 
    By understanding the evolution of  React rendering ,you have the necessary background for ther rest oof the section which will focus oon NEXT.JS
  
  summary In the Rsc architecture ad by extension in the next.js app router, cpomponents are server 


  Server zRendering Strageties 
  Static Rendering :
                    static rendering is a server rendering strategy where er generate HTml pages at thr time of bundeling our application 
                    This approach allows the page to built once ,cached by a CDn and sercer to the client almost instantly 
                    Thus optimization also enable you to share the result of thr rendering work among different users resultinfg in signifivant performance foryour application 
                    Static rendering is particularly usefulle for blog pages,e-commerce  product page documemntation and marketing pages 
   how to statically render?
    Static rendering is the dfault rendering strategy in thr app router 
    All routes are automatically prepade at built time without setup 

    "throuught this video you hane mentioned that HTMl is generated at built time .But there is no built time for our application yet,is there ?Aren't we running thr applicatin in developmen model ?

Production Server vs dev  server
 for the production server ,an optimized built is created once ,and you deploy thet build 
 A produvtion server ,on the other hand ,focus on the developer experiences 
 we can't afford to built our app once ,makes changes ,built and as so on 
 For the production builts ,a page will pre-render once we run the built command 
 In the development mode ,a page will be pre_rendered  for each request 

prefetching:
   it is the technique use to preload a route in the background before the uer navigate to it 
   Routes are automatically prefetch as they become visible in the users viewport,eighter when the page first loads or as ir comes into view through scrolling 
   For static routes ,the entire route is prefetched and chached by default 
    When we load the homepage ,next.js pre-fetches the about and dashboard routes ,keeping them ready for instant navigation 
Static Rendering Summary 
        static Rendering is a stratrgy where the HTml is generated at built time 
        Along with the HTml ,the RSc payload is created for each component and js chunks are produced foe the client_Side component in the browser 
        if you navigate directly to a page route ,the corresponding HTMl file is served 
        i you navigate to the route from s different one, the route is creeated on thr client side using the Rsc payload and js chunks ,without any additional request to the server 
        Static REndering is great for performance and use cased include blogs ,documentation ,marketing page etc 
Dynamic Rendering 
               it is a server rendering stragety where route are rendered for each user at request time 
               it is useful when a route has a data that is personalized to the user or contains information that can only be known at request time,suvh as cookies or the url's search paramater 
               News website ,personalized e-commerse apges and social mesias feed are some example where snamic rendering is beneficial 
  How to Dynamically Render 
   Durng rendering , if a dynamic function is discoverd ,NExt,js these dynamic functions are :Cookies (),headers (m=,and searchParams()
   Using any of these eill opt the whole route into dynamic rendering at requested time 
Ddddynamic REndering Summary 
      Dynamic Rendering is a strategy where the J+HTMl is generated as request time 
      Next.js automitacilly switches to dynamic rendering when it comes acros  a dynamic functon inthe component ,such as Cookies(),headers,and SearchParams object 
      THis form of rendering is great when we need redder HTMl personalized to a user ,such as a socila media feed 
      As a developer ,you do not need to choose between static and dynamic rendering 
      NExt,js autimayically choose the best rendering strategy for each route based in the feature and API's used
Streaming :
    straming is a stategy thst allow for progressive Ui from thr server 
    work in divided into chunks snd streamed to the client as shoon as ir's ready 
    This enable user to see parts of the page immidiately ,befoore the entire content has finished rendeing 
    Streaming significantly improves both the initial page loading performance and the rendering of Ui element tht rely on slower dat fetches ,which  would otherwise block the rendering of the entire route 
    stremming is integratd into next.JS APP  Router by Default   

Server and Client Components Pattern 
 Server Component 
 -Fetching the data 
 -direct accessing backend resources 
 -protecting the sensetive information(like acess tokens and API's key )on the server 
 -Keeping large dependencies server-side ,which hepls in reducing cilent-side js 


Client Component
-Adding interactivity
-Handeling events listners (such as onClick(),onChange(,ect)
-Mnaging state annd liifecycle effects (using hooks like useState(),useReducer(),useEffect())
-Using broeser exclusive API's 
-suing custome hooks 
-using react class Component 

Server-only code 
certain code is intendented to execute only on the server 
you might have modules or function s thst use multiple libraries ,use environment variables ,interact directly with a database  or process confidencial information 
since js modules can be shared .it's possibe for  code that's meant onlyfor the server to unintentionally end up in the client 
if server -side code  gets bundled into the client -side js it could lesd to a bloated bundle size ,expose secret keys ,databases queries and sensetive business logic 
it is crucial to seperate server-only code fromthe cilent-side code to protect the applications security and integrety 
 
server -only packages 
 provide a built-time error if developers accidently import one side of these modules into a client component 

Third party Packages 
 Third-pary 
 packages in the ecosystem sre gradually adapting ,begining to add the "use client" directive that rly on the client-side feature ,a=mnarking a clear distinction in their execution environment 
 Many components  from thr npm packages ,which traditionally leverage client-side features ,haven't yet integrated this directive 
 The abscence of "use client" means that while these components will function correctly in client components ,they may encounterd issues or ,ight not work at all within the server comoponents 
 to address this ,you cna erap third-party  compoonents that rly on client-only features in your own cilent components 

Context Provider 
  Context provider are TYpically renderd near the root of an application  to share global application state and logic
  for example ,the application THEME 
  however ,since React context is not suppoted in server components ,attempting to create a context at the rooot of your application willl results in an error 
  TO sddress this you can create a context and render its provider inside a seperate Cliengt Componennt 
  
Client only code  
just as  it's imoportant to restrict certain operation to the server ,it's equally important to confine somme functionality to the client side 
Client-only code typicallly inteacts with broeser-specific feature like dom ,the window object .localstorage etc which are not vailable on the server 
Ensuring that such code is executed only on the client side prevents errors during server-sider rendering 
To prevent unintentional server side usage of the client side code ,we can use a packages called client-only 

Client Component PLacement:
                             To compensate for server components not beinng able to manage stste snd handle interactivity ,you need to crate client components 
                             it's recommended to poosition these client components lower in your component tree 
                             

data fetching in app router :
                            
                             App Roouter uses the react sompoonents srchitecture ,which allows us to fetch the data using eighter server components oor client components 
                             it's advantageous to fetch dat using server component ,as they have direct acces to server side resources such as database or the sytem 
                             This not only tapes into teh server's computatiopnal power  and proximity to data sources for efficirnt dta fetching and rendering but also minimize teh need for client-side proessing 
                             we'll explore data fetching techniqies using both server and the client components in next.js 
                             Server components suport variious confiiguration foe caching ,revalidating and optimizing data fetching 
                             on the cliient side ,data fetching is typically managed through third-party libraries such as TanStack query  which offers its own roobust APIs 

Data fetvhing in the server Components :
 The Rsc architecture in the app router introduce support for async and await keywords in Server Components 
 THis alloes you to use the familiar js await syntsx by defining yourcomponent asynchronous function 
 This is the basis for  data fetching in Server Component 

loading and error states 
 Teaditionally in react ,you might mansge these states by creating seperate variiab;es snd confitional rendering Ui based on their values 
 to implement a loading state ,definr and export a React component in loading.tsx
 for handeling errors , define and expoert a react compoonent in error.tsx

 costome server 
 | Problem            | Fix             |
| ------------------ | --------------- |
| `"type": "module"` | Use `.cjs`      |
| json-server stable | CommonJS        |
| Node 24            | Fully supported |
| ESLint             | Scoped disable  |
You said your db.json looks like this:

{
  "products": [
    {
      "id": 1,
      "title": "product 1",
      "price": 1000,
      "description": "Description 1"
    },
    {
      "id": 2,
      "title": "product 2",
      "price": 2000,
      "description": "Description 2"
    },
    {
      "id": 3,
      "title": "product 3",
      "price": 3000,
      "description": "Description 3"
    }
  ]
}


Notice the top-level key: "products"

2️⃣ How JSON Server works

json-server automatically creates RESTful routes for each top-level key in your JSON:

JSON key	Generated route
"products"	/products
"users"	/users
"orders"	/orders

Basically:

Every top-level array in db.json becomes a route.

caching Data 
  BY default ,next.js automatiaclly caches the return values of fetch in the data caches on the server 

Data  Caches 
 What is data cache?
 it si server-side caches that persist the result of data fetches across incoming server request and deployment 

 Why it is requires ?
 THe data cache imoproves app performance and reduces cost by eliminating the need for re-fetching data from your data source eith every request 

 how does it work ?
 Here’s the short explanation of the diagram:

Browser requests /products.

Server checks cache:

MISS: Data not in cache → fetch from database/API → store in cache → send to browser.

HIT: Data in cache → send cached data → faster response.

Browser renders the page using the received data.

Key point: Cache improves speed by avoiding repeated fetches from the database/API

opting Out of Caching 
 FOr individual data fetches ,you can opt out of caching by setting the cache option to no-store
  const response = await fetch("http://localhost:3001/products", {
    cache: "no-store",
  }); 
  this cache:"no-store" doesnt cache the data from the api call it make each request every time user make the requst and doesnt cache the data 

  By Default Next.js will cache fetch() requestr that occure before any dynamic functio(Cookies(),headers(),searchParams())are  used and will nnot cache request founf after dynamic funncton 

  Option 1: Default first, no-store second

detailsResponse → may be cached by Next.js (default behavior).

products → { cache: "no-store" } → always fresh, hits API every time.

Option 2: No-store first, default second

detailsResponse → { cache: "no-store" } → always fresh.

products → default → may be cached.

Key point:

Each fetch decides its own caching behavior.

Order doesn’t matter — only whether cache: "no-store" or default is used.


Request Momoization:
       Request Momoization is a technique that deduplicates request form the same data witin a single render pass 
       This approach is a technique for re-use of the data in a react component tree,prevents redundant network calls and enhances performance 
       For this initial request ,data is fetched  form an externa source and the result is  stored in memory 
       Subquent requedt for the same data eithin the same render pass retrive the result from memory ,by passing hhe need to make the request again 
       This optimizatin not only enhance performance but also simplifies data fetching eithin a component tree 
       When the same data is needed across different componrnts in the route (eg in layout page ,and mmultiple components ),it eliminates the need to fetch hthe top of the tree and  pass proops between components 
       Instead ,dta can c=be fetched directly within the components that require it ,without concern about the performance implication of multiple network request for the same data 

key feature  
Request Memoization is a react feature ,not specifically a  Next.js feature 
Memoization only  applies to the GET method in fetch request        
MEmiization only applies within the react component tree it dooes't extend to fetch in routr handlers as they are not part of the react component tree 
For cases wjhere fetches is not suitable (eg some databases clients ,CMS client or GRaphQl clients),you can use the reACT cache function to memoize functions 

Caching in the Next.js 
By dafault Next.js chaches all fetch request in the data caches which is a persistent HTTp caches o the server 
THis hrlps optimize thr pages such as a blog post where the  content rerely changes 

We also know that we can opt out of caching 
-by using thr cachr :"no-store" option in the fetch request 
-by using a dynamic  function before making thr fetch request 
-by using a routee segment config like fetch-cachrh or dynamic 

A news website is  a great  example where you want to make sure you're  fetching the lattest data at all times
This apporach sems binary  eighter caching  or no caching 
In the real-world application ,there  are scenarios where a middile geound is required 
For example ,an event listing page might havr details such as schedule or venue informatio that changes occasionally 
In this cacher ,it is acceptable to fetch updated data once every houre as freahness is not critiical

 For  suuch scenario ,Next  .js alloes us to revalidate the cache

 Recalidation 
          it is the process of purging the data Caches and re fetching the lates data ]
  Time-Based Revalidation :
    Next.js automatically revalidates data after a certain amount time has passed


you caan set the revalidate route segment confoguration to establish the default revalidation time foe a layout or page:EXport const revalidate =10;
Regarding the revalidation frequency ,the lowest recalidatr time across each layout and pagr of a single route will detrmine the revalidation frequenncy of the entire route 



now Next.js 15 
What is next.js ?
Next.js is a react framework for building full-stack web application 
REact 
It's not feaslible to crate a fully-faettured application for peoduction React is a library for building user interfaces
You need to make secision about other fetaures such as touting ,data fetching and more 
In the other hand in  Next.js
ir uses React for building users interfaces 
Provides additional fetaurre that enab;e you to build production-ready application 
These feature include routing .optmize rendering ,dat fetching bundling compilinf and more 
You't have to install additional packages as next.js provides everything you need 
opinions and convention should be followed to implemrnt these feature 
The conventions have emerged from a team with yerrs i=of experience in writiong React apps for production 

what am i going to leran 
-how to setup a Next.js project fronn the scratch 
-The ins and outs of the client and the server Components 
-Hoe to use the new app router for defining pages and layouts 
-How Next.js hanndles navigation
 -Creating API routes Data fetching stategises 
 -Data mutations with Server Actions 
 -Authentication 


client Component                                 Server component 
-renderd in the browser                       -renderd exclusivly on the server 
-renderd to HTML once on the server           -never sent to the client 
-immidiately see the page's HTMl content       -fater page load 
rather thann a blank screen      
-can use state ,effects and browser-only Apis    -can't use interactivity features like useState or useEffect
-add "use client" directive aththe top of your file -server components are the default 


USES 
-fetchi the data                         intteractivity and ebvent listners 
-accessing backend resources             -using Hooks kie usestate or useEffect
-keeping sensetive infoormation on the server  -using browser-n=only Apis 
 

 Routing 
 Next.js has a file-system based routing mechanism 
 The way you organize  your files and folder determines the routes of your application 

 Routind conventions:
 -all route  must be placed inside the app folder 
 -every file thst  represent a route should be names as page.js or the page.tsx depending on what are you using typescript or the js
 -every folder corresponding to a path segments in the browsser url 

Sever Actions 
server action saresync functions that are seecuted on the server 
Thye alloe us to define and exicute server-logic  directly from our componrnts 
They're increadibely useful for handleling form submission ,updates databses or any operation that require server-side execution 
 
The server.json soenst make the changes on the datas so that we are using the mockapi.io for data fetching 
 for  the Authentication we will be uisng clerk 
  For the Authentication with clerk  we will be covering 

1.Signup 
2.signin
3.manage account 
4.Show the ui elememnt base on the auth status 
5 .Protect route based on the auth status
6.Read session and user  data 
7.sign out 

Wrapping up
we have covered 
introduction to next.js 15     navigation 
Development environment        Route handlers 
Project structure              Data fetching Staategies 
Sserver and  client Components sever Actions
App routers                    Authentication 
layout 